# Компилятор учебного языка программирования

## Описание проекта

Полнофункциональный компилятор для учебного языка программирования, который транслирует исходный код в ассемблер RISC-V. Проект реализован с использованием Flex и Bison для лексического и синтаксического анализа.

## Поддерживаемые возможности языка

### Типы данных
- `int` - целые числа
- `string` - строковые литералы

### Операторы
- **Объявление переменных**: `int x;`, `string msg;`
- **Присваивание**: `x = 5;`, `x = y + z;`
- **Вывод**: `print x;`, `print 42;`
- **Условные операторы**: `if (condition) { ... } else { ... }`
- **Циклы**: `while (condition) { ... }`
- **Блоки**: `{ statement1; statement2; }`

### Выражения
- **Арифметические**: `+`, `-`, `*`, `/`
- **Сравнения**: `<`, `>`, `==`
- **Логические**: `and`, `or`, `not`
- **Скобки для приоритета**: `(expression)`

### Комментарии
- Однострочные комментарии: `// это комментарий`

## Структура проекта

```
educational-compiler/
├── src/                    # Исходный код компилятора
│   ├── lexer.l            # Лексический анализатор (Flex)
│   ├── parser.y           # Синтаксический анализатор (Bison)
│   ├── ast.hpp/cpp        # Абстрактное синтаксическое дерево
│   ├── codegen.hpp/cpp    # Генератор кода RISC-V
│   └── main.cpp           # Основная программа
├── tests/                  # Тестовые программы
│   ├── test.prog          # Полная демонстрационная программа
│   ├── test_simple2.prog  # Простые конструкции
│   ├── test_if.prog       # Условные операторы
│   ├── test_while.prog    # Циклы
│   └── test_*.prog        # Другие тесты
├── cmake/                  # CMake скрипты
│   └── RunTests.cmake     # Автоматическое тестирование
├── build/                  # Директория сборки (создается автоматически)
├── CMakeLists.txt         # Конфигурация сборки
└── README.md              # Документация
```

## Сборка и запуск

### Требования
- CMake 3.10+
- Flex 2.6+
- Bison 3.0+
- GCC/Clang с поддержкой C++14

### Сборка
```bash
# Базовая сборка
mkdir build
cd build
cmake ..
make

# Использование custom targets
make clean-temp      # Очистка временных файлов
make clean-all      # Полная очистка включая build/
make debug          # Сборка в режиме отладки
make release        # Сборка в режиме релиза
make test-all       # Запуск всех тестов

# Альтернативно - прямой запуск тестов
./run_tests.sh      # Запуск тестового скрипта из корня проекта
```

### Запуск
```bash
# Компиляция в stdout
./build/bin/compiler tests/input.prog

# Компиляция в файл
./build/bin/compiler tests/input.prog output.s
```

## Примеры использования

### Простая программа
```
int x;
x = 42;
print x;
```

### Условные операторы и циклы
```
int i;
i = 0;
while (i < 3) {
    print i;
    i = i + 1;
}

if (i > 2) {
    print 100;
}
```

### Логические операции
```
int x;
int y;
x = 30;
y = 20;

if (x > 10 and y == 20) {
    print 1;
}

if (not (x < 10)) {
    print 2;
}
```

## Архитектура компилятора

### 1. Лексический анализ (Flex)
- Распознавание токенов: ключевые слова, идентификаторы, литералы, операторы
- Обработка комментариев и пробельных символов
- Генерация последовательности токенов

### 2. Синтаксический анализ (Bison)
- Построение абстрактного синтаксического дерева (AST)
- Обработка приоритетов операторов
- Семантические действия для создания узлов AST

### 3. Абстрактное синтаксическое дерево
Иерархия классов узлов:
- `ASTNode` - базовый класс
- `ProgramNode` - корневой узел программы
- `VarDeclNode` - объявление переменной
- `AssignNode` - присваивание
- `PrintNode` - оператор вывода
- `IfNode` - условный оператор
- `WhileNode` - оператор цикла
- `BlockNode` - блок операторов
- `BinaryOpNode` - бинарная операция
- `UnaryOpNode` - унарная операция
- `IdentifierNode` - идентификатор
- `IntLiteralNode` - целочисленный литерал
- `StringLiteralNode` - строковый литерал

### 4. Генерация кода RISC-V
- Управление стеком для локальных переменных
- Генерация меток для условных переходов и циклов
- Системные вызовы для ввода/вывода
- Оптимизация использования регистров

## Генерируемый ассемблер RISC-V

Компилятор генерирует стандартный ассемблер RISC-V с:
- Секцией `.data` для глобальных данных
- Секцией `.text` с точкой входа `_start`
- Корректным управлением стеком
- Системными вызовами Linux для ввода/вывода

### Пример сгенерированного кода
```assembly
.data

.text
.globl _start
_start:
    addi sp, sp, -4
    li a0, 42
    sw a0, -4(sp)   # x = a0
    lw a0, -4(sp)   # load x
    # Print integer
    mv a1, a0     # move value to a1
    li a7, 1      # print int system call
    ecall
    # Exit program
    li a7, 93     # exit system call
    li a0, 0      # exit status
    ecall
```

## Тестирование

В проекте содержится обширный набор тестов:
- `test.prog` - полная демонстрационная программа
- `test_*.prog` - тесты отдельных языковых конструкций
- Все тесты проходят без ошибок компиляции и сегментации

## Известные ограничения

1. Поддерживаются только целочисленные и строковые типы
2. Строковые переменные объявляются, но полноценная работа со строками не реализована
3. Нет проверки типов во время компиляции
4. Ограниченная обработка ошибок

## Статус проекта

✅ **ЗАВЕРШЕН** - Все основные требования выполнены:
- Лексический и синтаксический анализ
- Построение AST
- Генерация рабочего кода RISC-V
- Поддержка всех заявленных языковых конструкций
- Устранены критические ошибки (segmentation fault)
- Полное тестирование функциональности

## Авторы

Проект разработан в рамках курса "Конструирование компиляторов".